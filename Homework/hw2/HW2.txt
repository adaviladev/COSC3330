Name			: Adrian Davila
Course			: COSC 3330
PeopleSoft ID	: 0837023
Homework 2

2.1
	f = (g – 9) + h;

	addi f, g, -9
	add f, f, h


2.2
	f = ( g + h ) - i;

2.3
	For the following C statement, what is the corresponding
	MIPS assembly code? Assume that the variables f, g, h, i, and j are assigned to
	registers $s0, $s1, $s2, $s3, and $s4, respectively. Assume that the base address
	of the arrays A and B are in registers $s5 and $s6, respectively. Choose an 
	appropriate register to store the result.
	$s0 = f
	$s1 = g
	$s2 = h
	$s3 = i
	$s4 = j
	$s5 = A
	$s6 = B
	B[8] = A[i−j];

	sub $t0, $s3, $s4
	sll $t0, $t0, 2
	add $t1, $t0, $s5
	lw $t1, 0( $t1 )
	sw $t1, 32( $s6 )

2.4 
	assembly:
		sll $t0, $s0, 2 	# $t0 = f * 4
		add $t0, $s6, $t0 	# $t0 = &A[f]
		sll $t1, $s1, 2 	# $t1 = g * 4
		add $t1, $s7, $t1 	# $t1 = &B[g]
		lw $s0, 0($t0) 		# f = A[f]
		addi $t2, $t0, 8
		lw $t0, 0($t2)
		add $t0, $t0, $s0
		sw $t0, 0($t1)

	C:
		t0 = ( f * 4 ) + &A[ f ];
		t1 = ( g * 4 ) + &B[ g ];
		f = A[ f ];
		t2 = A[ h ];
		t0 = A[ h ];
		t0 += A[ f ];
		t0 = B[ g ];

2.5 // TODO
	assembly:
		sll $t0, $s0, 2 	# $t0 = f * 4
		add $t0, $s6, $t0 	# $t0 = &A[f]
		sll $t1, $s1, 2 	# $t1 = g * 4
		add $t1, $s7, $t1 	# $t1 = &B[g]
		lw $s0, 0($t0) 		# f = A[f]
		lw $t0, 8($t2)
		add $t0, $t0, $s0
		sw $t0, 0($t1)

	removed: 
		addi $t2, $t0, 8

2.6.1
	Array Index 	Byte Address	Present	Value	New	Value 	Array Index
	A[0] 			&24 			2				1			4
	A[1] 			&28 			4				2			0
	A[2] 			&32 			3				3			2
	A[3] 			&36 			6				4			1
	A[4] 			&40 			1				6			3

	C:
		int swap( int arr[] , int index1 , int index2 ) {
			int temp = arr[ index1 ];
			arr[ index1 ] = arr[ index2 ];
			arr[ index2 ] = temp;
		}
		int main() {
			int Array[] = { 2 , 4 , 3 , 6 , 1 };

			swap( Array , 3 , 4 );
			// Array[] = { 2 , 4 , 3 , 1 , 6 };
			
			swap( Array , 1 , 3 );
			// Array[] = { 2 , 1 , 3 , 4 , 6 };
			
			swap( Array , 0 , 1 );
			// Array[] = { 1 , 2 , 3 , 4 , 6 };
		}

2.7
	Big-Endian				Little-Endian
	Address		Data		Address		Data
	12			0001 0010	12			1010 1011
	8			1110 1111	8			1100 1101
	4			1100 1101	4			1110 1111
	0			1010 1011	0			0001 0010

	0x12efcdab
	0001 0010 1110 1111 1100 1101 1010 1011

2.11
	lw $t0, 4($gp) 		# fetch N
	mul $t0, $t0, $t0 	# N*N
	lw $t1, 4($gp) 		# fetch N
	ori $t2, $zero, 3 	# 3
	mul $t1, $t1, $t2 	# 3*N
	add $t2, $t0, $t1 	# N*N + 3*N
	sw $t2, 0($gp) 		# i = ...
	bgez $t2, $zero 8 	# if i≥0, skip jump
	jal 0x7FFC 			# else jump by 32764

	R-Type					opcode	rs		rt 		rd		shamt	funct
	mul $t0, $t0, $t0		000000	01000	01000	01000	00000	011000
	mul $t1, $t1, $t2		000000	01001	01010	01001	00000	011000
	add $t2, $t0, $t1		000000	01000	01001	01010	00000	100000

	I-Type					opcode	rs		rt 		immediate
	lw $t0, 4($gp)			100011	11100	01000	0000 0000 0000 0100
	lw $t1, 4($gp)			100011	11100	01000	0000 0000 0000 0100
	ori $t2, $zero, 3		001101	01010	00000	0000 0000 0000 0011
	sw $t2, 0($gp)			101011	11100	01010	0000 0000 0000 0000
	bgez $t2, $zero 8		000001	01010	00000	0000 0000 0000 1000

	J-Type					opcode	pseudo address
	jal 0x7FFC				000011	00 0000 0000 0111 1111 1111 1100

2.12.1
	$s0 = 0x8000 0000
	$s1 = 0xD000 0000

	add $t0, $s0, $s1
			 1000 0000 0000 0000 0000 0000 0000 0000
		+	 1101 0000 0000 0000 0000 0000 0000 0000

			2147483648
		+	3489660928
			5637144576 = 1 0101 0000 0000 0000 0000 0000 0000 0000
		   				 

2.12.2
	Results in overflow

2.12.3
	sub $t0, $s0, $s1
			1000 0000 0000 0000 0000 0000 0000 0000
		-	1101 0000 0000 0000 0000 0000 0000 0000

			2147483648
		+	3489660928
		   -1342177280 = 1011 0000 0000 0000 0000 0000 0000 0000

2.12.4
	No overflow

2.12.5
			 1000 0000 0000 0000 0000 0000 0000 0000
		+	 1101 0000 0000 0000 0000 0000 0000 0000

			2147483648 * 2
		+	3489660928
			7784628224 = 1 1101 0000 0000 0000 0000 0000 0000 0000

2.12.6
	Results in overflow

2.14
	1010 1101 0100 1001 0000 0000 0010 0000
	101011 01010 01001 0000 0000 0010 0000

	sw $t1, 32( $t2 )

2.15
	101011 01000 10100 0000 0000 0001 0000
	1010 1101 0001 0100 0000 0000 0001 0000

	I-Type => 0xAD140010

2.16 
	Provide the type, assembly language instruction, and binary representation of instruction described by the following MIPS fields:
	
	op=0	s=2		rt=3	rd=4	shamt=0	funct=35
	000000	00010	00011	00100	00000	100011
	subu $a0, $v0, $v1

2.17 
	Provide the type, assembly language instruction, and binary representation of instruction described by the following MIPS fields:

	op=0x23	rs=1	rt=2	const=0x4
	100011	00001	00010	0000 0000 0000 0100
	lw $v0, 4( $at )